---
title: "Using Monte Carlo to forecast NFL's fantasy results."
output:
  html_document:
    df_print: paged
editor_options:
  chunk_output_type: console
---

Neste post, vamos simular o resultados dos jogos da minha liga de Fantasy para projetando a pontuação dos times fazendo `data scrapping` para obter as previsões da performance dos jogadores, projetar a pontuação dele na liga e usar `Monte Carlo` para projetar os resultados dos jogos.

<!-- more -->

A temporada de [futebol americano](https://en.wikipedia.org/wiki/American_football) está de volta, e com ela o [Fantasy](http://fantasy.nfl.com/), o já tradicional jogo online no qual você reune os amigos, ou a galera do trabalho, e em uma "liga" particular, para escalar jogadores em times virtuais e companhar a performance dos mesmos a pontuação de seu time durante a rodada da [NFL](https://www.nfl.com/).

## ffanalytics package

O PhD em psicologia clínica e professor assistente [Isaac Petersen])(https://fantasyfootballanalytics.net/2013/03/isaac-petersen.html) autor do site [Fantasy Football Analytics](https://fantasyfootballanalytics.net), que faz projeções e análise de resultados do fantasy, fez um grande trabalho com o pacote [ffanalytics](https://fantasyfootballanalytics.net/2016/06/ffanalytics-r-package-fantasy-football-data-analysis.html) disponibilizado no [GitHub](https://github.com/FantasyFootballAnalytics/ffanalytics). 

Este pacote faz o [`data scrapping`](https://fantasyfootballanalytics.net/2014/06/scraping-fantasy-football-projections.html) de vários sites que fazem previsões de jogadores, como [ESPN](http://games.espn.com/ffl/tools/projections), [CBS](https://www.cbssports.com/fantasy/football/stats/sortable/points/QB/standard/projections/2018/3?print_rows=100), [Yahoo](https://sports.yahoo.com/news/week-8-fantasy-football-rankings-helping-set-lineup-210614393.html) e o próprio site da [NFL](http://m.fantasy.nfl.com/research/projections), aplica as regras de pontuações do fantasy (que inclusive [podem ser cutomizadas](https://github.com/FantasyFootballAnalytics/ffanalytics/blob/master/R/scoring_rules.R) para a sua Liga) e [calcula a pontuação](https://fantasyfootballanalytics.net/2014/06/custom-rankings-and-projections-for-your-league.html) possível para cada uma das projeções.

Por fim, o pacote faz a analise dos pontos obtidos possibilitando fazer [projeções de performance](https://fantasyfootballanalytics.net/2014/06/custom-rankings-and-projections-for-your-league.html) dos resultados, aggregando numa so visão a projeção de vários sites. Isaac publica semanalmente o [ranking das projeções](https://fantasyfootballanalytics.net/2018/10/gold-mining-week-7-2018.html) por posição, para os jogos da rodada, usando algumas regras de pontuação `standard` e `PPR`. 

Com todo o trabalho duro, de fazer o `data scrapping` e aplicar as regras do fantasy para calcular a pontuação já feita pelo pacote, podemos essa a informação para projetar os resultados dos times escalados nas ligas do fantasy para fazer forecast de placar dos jogos, bastando para isso obter os dados dos times, confrontos e escalações no próprio fantasy.

```{r setup, echo=FALSE}
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```


## Fantasy API - Getting the Team's Matchups and Rosters

Para obter os times, a escação e os confrontos da rodada de uma liga do fantasy, podemos usar a [Web API](http://api.fantasy.nfl.com/) disponibilizada. Embora tenha alguns métodos *depreciated* eles ainda funcionam e atendem ao propósito de obter as informações desejadas. Em particular precisamos apenas acessar os métodos que diz quais os jogos  [`/league/matchups`](http://api.fantasy.nfl.com/v1/docs/service?serviceName=leagueMatchups) que recebe como parametros de entrada o `token` de autenticação, o `id` da liga e a `week` da rodada devolvendo os jogos programados para aquela semana, e a API [`/league/team/matchup`](http://api.fantasy.nfl.com/v1/docs/service?serviceName=leagueTeamMatchup) que, além dos parâmetros anteriores, também recebe o `id` do time para retornar o roster escalado. 
Podemos invocar a API usando o pacote `httr` e processar o json de resposta usando o `jsonlite`.

```{r config, cache=TRUE}
# Storing the Access Token and League ID locally
# I use a yalm file to avoid hard-code them 
# or eventually version them in the GitHub :)
library(yaml)

config <- yaml.load_file("./config/config.yml")
leagueId <- config$leagueId
authToken <- config$authToken
```

```{r restoreResp1, echo=FALSE}
resp <- readRDS("./R/post/cache/league_matchups.rds")
```

```{r getMatchups, eval=FALSE}
# invoking the API
library(httr)
library(glue) # to easily replace vars in the url

# league/matchups url
url <- "http://api.fantasy.nfl.com/v1/league/matchups?leagueId={leagueId}&week={week}&format=json&authToken={authToken}"
week <- 5

# faz a chamada na api
resp <- httr::GET(glue(url))
```

```{r respOk}
# Is it ok?
resp$status_code
```

Obtida a resposta da chamada, tratamos o *json* de retorno para organizar os dados e obter a escação de times.

```{r matchupHandling, warning=FALSE, message=FALSE}

library(jsonlite)
library(tidyverse)

# to convert the json in a "tabular-tibble form"
resp %>% 
  httr::content(as="text") %>%
  fromJSON(simplifyDataFrame = T) %$%  
  leagues %$%
  matchups %>%
  .[[1]] %>% 
  jsonlite::flatten() %>% 
  as.tibble() -> matchups

 matchups %>% 
   select(awayTeam.id, awayTeam.name, homeTeam.name, homeTeam.id)
```

Fazemos novas chamadas à API para obter a escalação de cada um dos times nessa rodada.

```{r loadRosters, echo=FALSE}
rosters.json <- readRDS("./R/post/cache/rosters_json.rds")
```
```{r getRosters, eval=FALSE,  warning=FALSE, message=FALSE}

# for each teamIds in the matchup
c(matchups$awayTeam.id) %>%
  map(
    function(.teamId, .week, .leagueId, .authToken, .url) {
      # make the API call
      httr::GET(glue(.url)) %>%
        httr::content(as = "text") %>%
        fromJSON(simplifyDataFrame = T) %>% # transform response body in json
        return()
    },
    .week      = week,
    .leagueId  = leagueId,
    .authToken = authToken,
    .url       = "http://api.fantasy.nfl.com/v1/league/team/matchup?leagueId={.leagueId}&teamId={.teamId}&week={.week}&authToken={.authToken}&format=json"
  )  -> rosters.json
```


```{r checkResponse}
# this is a list with the team rosters used in this week
rosters.json[[1]]$leagues$matchup$homeTeam$name
rosters.json[[1]]$leagues$matchup$homeTeam$players[[1]] %>%
  select(id, name, position, teamAbbr) %>% 
  as.tibble()
```

Com a escalação dos times na mão (em formato *json*) processamos os dados para facilitar o tratamento. 

```{r extractTeams}

# auxiliar transformation to extract team roster
extractTeam <- . %>% 
  .$players %>% 
  .[[1]] %>% 
  select( src_id=id, name, position, rosterSlot, fantasyPts ) %>%
  jsonlite::flatten() %>% 
  as.tibble() %>% 
  select(-fantasyPts.week.season, -fantasyPts.week.week ) %>% 
  rename(points = fantasyPts.week.pts) %>% 
  mutate(
    src_id = as.integer(src_id), 
    points = as.numeric(points)
  )

# extract each roster
rosters.json %>% 
  map(function(.json){
    matchup <- .json$leagues$matchup
    tibble(
      home.teamId = as.integer(matchup$homeTeam$id),
      home.name   = matchup$homeTeam$name,
      home.logo   = matchup$homeTeam$logoUrl,
      home.pts    = as.numeric(matchup$homeTeam$pts),
      home.roster = list(extractTeam(matchup$homeTeam)),
      away.teamId = as.integer(matchup$awayTeam$id),
      away.name   = matchup$awayTeam$name,
      away.logo   = matchup$awayTeam$logoUrl,
      away.pts    = as.numeric(matchup$awayTeam$pts),
      away.roster = list(extractTeam(matchup$awayTeam))
    ) %>% 
      return()
  }) %>% bind_rows() -> matchups.rosters

# check the matchups QBs for each team 
matchups.rosters %>% 
  mutate( away.qb = map(away.roster, function(roster) roster %>% filter(rosterSlot=="QB")),
          home.qb = map(home.roster, function(roster) roster %>% filter(rosterSlot=="QB")) ) %>%
  unnest(away.qb, home.qb, .sep=".") %>% 
  select(away.team = away.name, away.qb.name, home.qb.name, home.team=home.name )

```

Agora nós temos um `tibble` com os jogos entre os times e, aninhado no registro, as respectivas escalações. Agora será necessário usar o `ffanalytis` para obter a performance e pontuação de cada jogador.

## Forecast players perform

Vamos usar o pacote `ffanalytics` para fazer o `data scrapping` das previsões para cada jogador da liga feito pelos principais sites que acompanham e fazem esse tipo de previsão.

```{r scrap, eval=FALSE, message=FALSE, warning=FALSE, error=FALSE}

library(ffanalytics)
scrap <- scrape_data(pos = c("QB", "RB", "WR", "TE", "K", "DST"),
                     season = 2018,
                     week = week)

```
```{r loadScrap}
scrap <- readRDS("./R/post/cache/scrap.rds")
```

A função `scrape_data` devolve uma lista por posição, com as projeções de performance dos jogadores naquela posição. É assim porque as previsões para cada posição possuem atributos diferentes, por exemplo, *Kickers* são avaliados pelo número de *field goals* e distâncias dos chutes enquanto *Quaterbacks* pelos números de lançamentos e jardas lançadas.

```{r scrapReturn}

# Quaterback Projection Attributes
scrap$QB %>%  
  filter(player=="Drew Brees") %>% 
  select(1:10)

# Kickers Projection Attributes
scrap$K %>%  
  filter(player=="Justin Tucker") %>% 
  select(1:10)

```

Com as projeções na mão, e usando o `ffanalytics` agora é possível calcular a quantidade de pontos que um jogador fará se fizer o que cada previsão estima que ele faça. Entretanto o pacote não exporta a função que faz o cálculo individual para aplicar somente a uma previsão, mas ela é uma etapa necessária para calcular a [tabela de projeções](https://github.com/FantasyFootballAnalytics/ffanalytics#calculating-projections) que o site usa em seus [gráficos](https://fantasyfootballanalytics.net/2018/10/gold-mining-week-7-2018.html).

Mas como o projeto está no GitHub é possível baixar o código, carregar o script e acessar diretamente a função que faz o cálculo por jogador e site, ela se chama `source_points()`, presente no script [calc_projections.R](https://github.com/FantasyFootballAnalytics/ffanalytics/blob/master/R/calc_projections.R#L90). É possível carregar o script (e suas dependências) para poder invocá-la diretamente.

```{r loadPoints, echo=FALSE}
players.points <- readRDS("./R/post/cache/players_points.rds") %>% 
  mutate(id = as.integer(id) )
```
```{r source_points, eval=FALSE}

# function to access 'source_points' directly
playerPointsProjections <- function(.scrap, .score_rules){
  source("../ffanalytics/R/calc_projections.R")
  source("../ffanalytics/R/stats_aggregation.R")
  source("../ffanalytics/R/source_classes.R")
  source("../ffanalytics/R/custom_scoring.R")
  source("../ffanalytics/R/scoring_rules.R")
  source("../ffanalytics/R/make_scoring.R")
  source("../ffanalytics/R/recode_vars.R")
  source("../ffanalytics/R/impute_funcs.R")
  source_points(.scrap, .score_rules)
}

# customized scoring rules
source("./R/post/score_settings.R") 
players.points <- playerPointsProjections(scrap, dudes.score.settings)
```
```{r head_players_points, echo=FALSE}
head(players.points)
```

```{r fixKickers, echo=FALSE,  warning=FALSE, message=FALSE}
# fix the kickers pontuation
scrap$K %>%
  mutate(pos="K") %>% 
  select(pos, data_src, id, points=site_pts) %>% 
  mutate(id = as.integer(id)) %>% 
  bind_rows(filter(players.points,pos!="K"))  -> players.points
```

## Merging Rosters and Predictions

Temos agora a escalação dos times e as projeções de pontuação dos sites para cada jogadores, precisamos unir os datasets, mas antes é necessário "combinar" os `ids` dos jogadores. Se vcs repararem nos dados mostrados, a identificação de cada um jogador é diferente em cada um dos sites, o `ffanalytics` da o nome à esse `id` de `src_id`, mas unifica os resultados a um `id` unificado, identificado como `id`.

A escalação dos times foi obtida do site do `fantasy` então segue a identificação do `src_id` da `NFL`, para fazer o *merge* entre os dois será necessário mapear o `src_id` da `NFL` para o `id` do `ffanalytics`. Podemos extrair o mapeamento de 'ids' do scrapping de dados, pois tanto ambos estão lá quando o scrapping é originado do site da NFL:

```{r ids}
# look the presence of both ids in the projection table
scrap$WR %>% 
  filter( data_src=="NFL" ) %>% 
  select(1:4) %>% 
  head()
```

```{r echo=FALSE}
players.ids <- readRDS("./R/post/cache/nfl_players_id.rds")
```

```{r playerIdsTable, eval=FALSE}
# extracting id and src_id from all positions
scrap %>%
  map(function(dft){
    dft %>% 
      filter(data_src=="NFL") %>% 
      select(id, src_id, player, team, pos) %>% 
      return()
  }) %>% 
  bind_rows() %>%
  distinct() -> players.ids
```

```{r ids.mapping}
# ID mapping
head(players.ids)
```

Agora podemos fazer o *merging* das predições dos jogadores às escalações do time. 

```{r mergePlayers}
# nest by "id" and merge with "src_id"
players.points %>% 
  select(-pos) %>% 
  group_by(id) %>% 
  nest(.key="points.range") %>%
  # merge ID with SRC_ID
  inner_join(players.ids, by = c("id")) %>%
  select(id, src_id, player, pos, team, points.range) %>% 
  # keep only "ids" at top level
  select(id, src_id, points.range) -> players.ids.points

# auxiliary function to merge roster with player points
mergePoints <- function(.roster, .points){
  .roster %>% 
    left_join(.points, by="src_id") %>% 
    return()
}

# merge points in rosters
matchups.rosters %>% 
  mutate(
    home.roster = map(home.roster, mergePoints, .points=players.ids.points),
    away.roster = map(away.roster, mergePoints, .points=players.ids.points)
  ) -> matchups.points

```

Convém notar que estamos usando uma estrutura de *data.frames* aninhados, mais conhecido como [*nested*](https://r4ds.had.co.nz/many-models.html), ou seja, nós temos um *data.frame* de *matchups* onde cada linha é uma partida. Em cada partida há duas colunas de escalação ("casa" e "visitante"), essas colunas guardam um outro *data.frame*, contendo a escalação. Neste *data.frame*, cada linha é um jogador, e para cada um há uma coluna chamada *points.range* que também contém um *data.frame*, contendo a previsão de pontuação de cada site.

```{r nestedDataframeExplorer}

# "father" dataframe and the first nested column
matchups.points %>% 
  select( home.name, home.roster )

# seeing the first nested data.frame
matchups.points[1,]$home.roster[[1]] 

# look the second level dataframe
matchups.points[1,]$home.roster[[1]][1,]$points.range[[1]] 

```

[Nested data.frames](https://r4ds.had.co.nz/many-models.html) é um modelo poderoso, permite manter os dados relacionais juntos e com fácil manipulação.

## Monte Carlo

Para simular o resultado das partidas da rodada, precisamos simular a pontuação obtida por cada um dos times e para tal precisamos simular a pontuação dos titulares desse time. Para tal, usaremos [Monte Carlo](https://en.wikipedia.org/wiki/Monte_Carlo_method).

Para simular a pontuação dos jogadores vamos considerar que cada um dos jogadores pode fazer uma das pontuações projetadas pelos sites de previsão. Por motivos de simplicidade para nesse post, podemos assumir que as chances são iguais para qualquer uma das pontuações projetadas.

Neste caso a simulação de UMA partirda usando Monte Carlo consiste então em:

1. Para cada jogador do time, sorteia-se um dos números projetados possíveis
2. Somam-se os pontos sorteados dos jogadores titulares: esse será a pontuação do time
3. Compara-se a pontuação do time *home* com o time *away* para determinar quem ganhou
4. Computa-se uma vitoria para o time com maior pontuação 

Esse procedimento é repetido *N* vezes, simulando várias partidas, para se determinar as chances de vitória de um time, computa-se o total de vezes em que o time foi vencedor e divide-se pelo total de simulações. Assim teremos as chances de cada time ganhar a partida, pois as simulações refletirão as inúmeros combinações de pontuação entre os jogadores e entre os times.

Notas-se que adotamos que cada jogador tem iguais chance de ter qualquer uma das pontuações projetadas como pontuação da simulação, modelos mais sofisticados poderiam ponderar ranges diferentes com probabilidades diferentes entre as projeções, incluindo avaliar o histórico de performance da site, mas deixaremos isso para um outro post.

```{r simulation}

# It's better you read this code chunk from botton to up :)

### Auxiliary functions

# function to generate .n possible pontuations from .points.range
# it's used to generate the .n simulations to each player
simPlayer <- function(.points.range, .n){

  # just check if the points.range isn't empty
  if(is.null(.points.range)) return( vector(mode = "numeric",.n) )
  if(nrow(.points.range)==0) return( vector(mode = "numeric",.n) )

  # generate a .n vector samples from points.range
  .points.range$points %>% 
    sample(size = .n, replace = T) %>%
    return()

}

# function to add the player pontuation to the team roster dataframe
simTeam <- function(.roster, .n){
  .roster %>% 
    mutate( sim.player = map(points.range, simPlayer, .n=.n) )  %>% 
    return()
}

# this function is in charge to sum the pontuations from 
# each player to generate the .n-size vector with team pontuation
simTeamPoints <- function(.roster){
  .roster %>% 
    filter(rosterSlot!="BN") %>%  # exclude player in bench
    pull(sim.player) %>%          # get the player pontuation simulation
    bind_cols() %>%               # binds the pontuation toghether 
    as.matrix() %>%               # now we have an matrix with # players x # .n simulations
    rowSums(na.rm = T) %>%        # sum each row (simuilation) to get a .n-vector 
    return()                      # each position in this vector is a possible team pontuation
}

### Simulation Code

# number of simulations
n <- 2000

# in the matchups dataframe
matchups.points %>% 
  mutate(
    home.roster = map(home.roster, simTeam, .n=n), # add players simulation pointes
    away.roster = map(away.roster, simTeam, .n=n), # to each roster
    home.sim    = map(home.roster, simTeamPoints), # computes the team simulation
    away.sim    = map(away.roster, simTeamPoints)  # points
  ) %>% 
  mutate( 
    home.win    = map2(home.sim, away.sim, function(.x,.y) (.x > .y) ), # computes the 
    away.win    = map(home.win, function(.x) (!.x)), # number of victures of each team
    home.win.prob = map(home.win, mean, na.rm = T),  # computess the % of victories
    away.win.prob = map(away.win, mean, na.rm = T)   # computess the % of victories
  ) %>%
  mutate(
    # this calculate the difference of score points in each simulation
    score.diff    = map2(home.sim, away.sim, function(.x,.y){.x - .y})
  ) -> simulation

```

