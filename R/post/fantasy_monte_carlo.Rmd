---
title: "Using Monte Carlo to forecast NFL's fantasy results."
output:
  html_document:
    df_print: paged
editor_options:
  chunk_output_type: console
---

Neste post, vamos simular o resultados dos jogos da minha liga de Fantasy para projetando a pontuação dos times fazendo `data scrapping` para obter as previsões da performance dos jogadores, projetar a pontuação dele na liga e usar `Monte Carlo` para projetar os resultados dos jogos.

<!-- more -->

A temporada de [futebol americano](https://en.wikipedia.org/wiki/American_football) está de volta, e com ela o [Fantasy](http://fantasy.nfl.com/), o já tradicional jogo online no qual você reune os amigos, ou a galera do trabalho, e em uma "liga" particular, para escalar jogadores em times virtuais e companhar a performance dos mesmos a pontuação de seu time durante a rodada da [NFL](https://www.nfl.com/).

## ffanalytics package

O PhD em psicologia clínica e professor assistente [Isaac Petersen])(https://fantasyfootballanalytics.net/2013/03/isaac-petersen.html) autor do site [Fantasy Football Analytics](https://fantasyfootballanalytics.net), que faz projeções e análise de resultados do fantasy, fez um grande trabalho com o pacote [ffanalytics](https://fantasyfootballanalytics.net/2016/06/ffanalytics-r-package-fantasy-football-data-analysis.html) disponibilizado no [GitHub](https://github.com/FantasyFootballAnalytics/ffanalytics). 

Este pacote faz o [`data scrapping`](https://fantasyfootballanalytics.net/2014/06/scraping-fantasy-football-projections.html) de vários sites que fazem previsões de jogadores, como [ESPN](http://games.espn.com/ffl/tools/projections), [CBS](https://www.cbssports.com/fantasy/football/stats/sortable/points/QB/standard/projections/2018/3?print_rows=100), [Yahoo](https://sports.yahoo.com/news/week-8-fantasy-football-rankings-helping-set-lineup-210614393.html) e o próprio site da [NFL](http://m.fantasy.nfl.com/research/projections), aplica as regras de pontuações do fantasy (que inclusive [podem ser cutomizadas](https://github.com/FantasyFootballAnalytics/ffanalytics/blob/master/R/scoring_rules.R) para a sua Liga) e [calcula a pontuação](https://fantasyfootballanalytics.net/2014/06/custom-rankings-and-projections-for-your-league.html) possível para cada uma das projeções.

Por fim, o pacote faz a analise dos pontos obtidos possibilitando fazer [projeções de performance](https://fantasyfootballanalytics.net/2014/06/custom-rankings-and-projections-for-your-league.html) dos resultados, aggregando numa so visão a projeção de vários sites. Isaac publica semanalmente o [ranking das projeções](https://fantasyfootballanalytics.net/2018/10/gold-mining-week-7-2018.html) por posição, para os jogos da rodada, usando algumas regras de pontuação `standard` e `PPR`. 

Com todo o trabalho duro, de fazer o `data scrapping` e aplicar as regras do fantasy para calcular a pontuação já feita pelo pacote, podemos essa a informação para projetar os resultados dos times escalados nas ligas do fantasy para fazer forecast de placar dos jogos, bastando para isso obter os dados dos times, confrontos e escalações no próprio fantasy.

```{r setup, echo=FALSE}
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```


## Fantasy API - Getting the Team's Matchups and Rosters

Para obter os times, a escação e os confrontos da rodada de uma liga do fantasy, podemos usar a [Web API](http://api.fantasy.nfl.com/) disponibilizada. Embora tenha alguns métodos *depreciated* eles ainda funcionam e atendem ao propósito de obter as informações desejadas. Em particular precisamos apenas acessar os métodos que diz quais os jogos  [`/league/matchups`](http://api.fantasy.nfl.com/v1/docs/service?serviceName=leagueMatchups) que recebe como parametros de entrada o `token` de autenticação, o `id` da liga e a `week` da rodada devolvendo os jogos programados para aquela semana, e a API [`/league/team/matchup`](http://api.fantasy.nfl.com/v1/docs/service?serviceName=leagueTeamMatchup) que, além dos parâmetros anteriores, também recebe o `id` do time para retornar o roster escalado. 
Podemos invocar a API usando o pacote `httr` e processar o json de resposta usando o `jsonlite`.

```{r config, cache=TRUE}
# Storing the Access Token and League ID locally
# I use a yalm file to avoid hard-code them 
# or eventually version them in the GitHub :)
library(yaml)

config <- yaml.load_file("./config/config.yml")
leagueId <- config$leagueId
authToken <- config$authToken
```

```{r restoreResp1, echo=FALSE}
resp <- readRDS("./R/post/cache/league_matchups.rds")
```

```{r getMatchups, eval=FALSE}
# invoking the API
library(httr)
library(glue) # to easily replace vars in the url

# league/matchups url
url <- "http://api.fantasy.nfl.com/v1/league/matchups?leagueId={leagueId}&week={week}&format=json&authToken={authToken}"
week <- 5

# faz a chamada na api
resp <- httr::GET(glue(url))
```

```{r respOk}
# Is it ok?
resp$status_code
```

Obtida a resposta da chamada, tratamos o *json* de retorno para organizar os dados e obter a escação de times.

```{r matchupHandling, warning=FALSE, message=FALSE}

library(jsonlite)
library(tidyverse)

# to convert the json in a "tabular-tibble form"
resp %>% 
  httr::content(as="text") %>%
  fromJSON(simplifyDataFrame = T) %$%  
  leagues %$%
  matchups %>%
  .[[1]] %>% 
  jsonlite::flatten() %>% 
  as.tibble() -> matchups

 matchups %>% 
   select(awayTeam.id, awayTeam.name, homeTeam.name, homeTeam.id)
```

Fazemos novas chamadas à API para obter a escalação de cada um dos times nessa rodada.

```{r loadRosters, echo=FALSE}
rosters.json <- readRDS("./R/post/cache/rosters_json.rds")
```
```{r getRosters, eval=FALSE, cache=TRUE, warning=FALSE, message=FALSE}

# for each teamIds in the matchup
c(matchups$awayTeam.id) %>%
  map(
    function(.teamId, .week, .leagueId, .authToken, .url) {
      # make the API call
      httr::GET(glue(.url)) %>%
        httr::content(as = "text") %>%
        fromJSON(simplifyDataFrame = T) %>% # transform response body in json
        return()
    },
    .week      = week,
    .leagueId  = leagueId,
    .authToken = authToken,
    .url       = "http://api.fantasy.nfl.com/v1/league/team/matchup?leagueId={.leagueId}&teamId={.teamId}&week={.week}&authToken={.authToken}&format=json"
  )  -> rosters.json
```


```{r checkResponse}
# this is a list with the team rosters used in this week
rosters.json[[1]]$leagues$matchup$homeTeam$name
rosters.json[[1]]$leagues$matchup$homeTeam$players[[1]] %>%
  select(id, name, position, teamAbbr) %>% 
  as.tibble()
```

Com a escalação dos times na mão (em formato *json*) processamos os dados para facilitar o tratamento. 

```{r}

# auxiliar transformation to extract team roster
extractTeam <- . %>% 
  .$players %>% 
  .[[1]] %>% 
  select( src_id=id, name, position, rosterSlot, fantasyPts ) %>%
  jsonlite::flatten() %>% 
  select(-fantasyPts.week.season, -fantasyPts.week.week ) %>% 
  rename(points = fantasyPts.week.pts) %>% 
  mutate(points = as.numeric(points) )

# extract each roster
rosters.json %>% 
  map(function(.json){
    matchup <- .json$leagues$matchup
    tibble(
      home.teamId = matchup$homeTeam$id,
      home.name   = matchup$homeTeam$name,
      home.logo   = matchup$homeTeam$logoUrl,
      home.pts    = as.numeric(matchup$homeTeam$pts),
      home.roster = list(extractTeam(matchup$homeTeam)),
      away.teamId = matchup$awayTeam$id,
      away.name   = matchup$awayTeam$name,
      away.logo   = matchup$awayTeam$logoUrl,
      away.pts    = as.numeric(matchup$awayTeam$pts),
      away.roster = list(extractTeam(matchup$awayTeam))
    ) %>% 
      return()
  }) %>% bind_rows() -> matchups.rosters

# check the matchups QBs for each team 
matchups.rosters %>% 
  mutate( away.qb = map(away.roster, function(roster) roster %>% filter(rosterSlot=="QB")),
          home.qb = map(home.roster, function(roster) roster %>% filter(rosterSlot=="QB")) ) %>%
  unnest(away.qb, home.qb, .sep=".") %>% 
  select(away.team = away.name, away.qb.name, home.qb.name, home.team=home.name )

```

Agora nós temos os jogos entre os times e suas escalações, para fazer o forecast de cada match precisamos usar o `ffanalytis` para obter a performance e pontuação de cada jogador.

## Forecast players perform

Vamos usar o pacote `ffanalytics` para fazer o `data scrapping` das previsões para cada jogador da liga feito pelos principais sites que acompanham e fazem esse tipo de previsão.

```{r scrap, eval=FALSE, message=FALSE, warning=FALSE, error=FALSE}

library(ffanalytics)
scrap <- scrape_data(pos = c("QB", "RB", "WR", "TE", "K", "DST"),
                     season = 2018,
                     week = week)

```
```{r loadScrap}
scrap <- readRDS("./R/post/cache/scrap.rds")
```

A função `scrape_data` devolve uma lista por posição, com as projeções de performance dos jogadores naquela posição. É assim porque as previsões para cada posição possuem atributos diferentes, por exemplo, *Kickers* são avaliados pelo número de *field goals* e distâncias dos chutes enquanto *Quaterbacks* pelos números de lançamentos e jardas lançadas.

```{r scrapReturn}

# Quaterback Projection Attributes
scrap$QB %>%  
  filter(player=="Drew Brees") %>% 
  select(1:10)

# Kickers Projection Attributes
scrap$K %>%  
  filter(player=="Justin Tucker") %>% 
  select(1:10)

```

Com as projeções na mão, e usando o `ffanalytics` agora é possível calcular a quantidade de pontos que um jogador fará se fizer o que cada previsão estima que ele faça. Entretanto o pacote não exporta a função que faz o cálculo individual para aplicar somente a uma previsão, mas ela é uma etapa necessária para calcular a [tabela de projeções](https://github.com/FantasyFootballAnalytics/ffanalytics#calculating-projections) que o site usa em seus [gráficos](https://fantasyfootballanalytics.net/2018/10/gold-mining-week-7-2018.html).

Mas como o projeto está no GitHub é possível baixar o código, carregar o script e acessar diretamente a função que faz o cálculo por jogador e site, ela se chama `source_points()`, presente no script [calc_projections.R](https://github.com/FantasyFootballAnalytics/ffanalytics/blob/master/R/calc_projections.R#L90). É possível carregar o script (e suas dependências) para poder invocá-la diretamente.

```{r loadPoints, echo=FALSE}
players.points <- readRDS("./R/post/cache/players_points.rds")
```
```{r source_points, eval=FALSE}

# function to access 'source_points' directly
playerPointsProjections <- function(.scrap, .score_rules){
  source("../ffanalytics/R/calc_projections.R")
  source("../ffanalytics/R/stats_aggregation.R")
  source("../ffanalytics/R/source_classes.R")
  source("../ffanalytics/R/custom_scoring.R")
  source("../ffanalytics/R/scoring_rules.R")
  source("../ffanalytics/R/make_scoring.R")
  source("../ffanalytics/R/recode_vars.R")
  source("../ffanalytics/R/impute_funcs.R")
  source_points(.scrap, .score_rules)
}

# customized scoring rules
source("./R/post/score_settings.R") 
players.points <- playerPointsProjections(scrap, dudes.score.settings)
head(players.points)
```

```{r fixKickers, echo=FALSE, cache=TRUE, warning=FALSE, message=FALSE}
# fix the kickers pontuation
scrap$K %>%
  mutate(pos="K") %>% 
  select(pos, data_src, id, points=site_pts) %>% 
  bind_rows(filter(players.points,pos!="K"))  -> players.points
```

```{r mergePlayers}
players.points %>% 
  group_by(id, pos) %>% 
  nest(.key="points.range")
```

