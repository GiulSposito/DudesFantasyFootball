---
title: "Using Monte Carlo to forecast NFL's fantasy results."
output:
  html_document:
    df_print: paged
editor_options:
  chunk_output_type: console
---

Neste post, vamos simular o resultados dos jogos da minha liga de Fantasy para projetando a pontuação dos times fazendo `data scrapping` para obter as previsões da performance dos jogadores, projetar a pontuação dele na liga e usar `Monte Carlo` para projetar os resultados dos jogos.

<!-- more -->

A temporada de [futebol americano](https://en.wikipedia.org/wiki/American_football) está de volta, e com ela o [Fantasy](http://fantasy.nfl.com/), o já tradicional jogo online no qual você reune os amigos, ou a galera do trabalho, e em uma "liga" particular, para escalar jogadores em times virtuais e companhar a performance dos mesmos a pontuação de seu time durante a rodada da [NFL](https://www.nfl.com/).

## ffanalytics package

O PhD em psicologia clínica e professor assistente [Isaac Petersen])(https://fantasyfootballanalytics.net/2013/03/isaac-petersen.html) autor do site [Fantasy Football Analytics](https://fantasyfootballanalytics.net), que faz projeções e análise de resultados do fantasy, fez um grande trabalho com o pacote [ffanalytics](https://fantasyfootballanalytics.net/2016/06/ffanalytics-r-package-fantasy-football-data-analysis.html) disponibilizado no [GitHub](https://github.com/FantasyFootballAnalytics/ffanalytics). 

Este pacote faz o [`data scrapping`](https://fantasyfootballanalytics.net/2014/06/scraping-fantasy-football-projections.html) de vários sites que fazem previsões de jogadores, como [ESPN](http://games.espn.com/ffl/tools/projections), [CBS](https://www.cbssports.com/fantasy/football/stats/sortable/points/QB/standard/projections/2018/3?print_rows=100), [Yahoo](https://sports.yahoo.com/news/week-8-fantasy-football-rankings-helping-set-lineup-210614393.html) e o próprio site da [NFL](http://m.fantasy.nfl.com/research/projections), aplica as regras de pontuações do fantasy (que inclusive [podem ser cutomizadas](https://github.com/FantasyFootballAnalytics/ffanalytics/blob/master/R/scoring_rules.R) para a sua Liga) e [calcula a pontuação](https://fantasyfootballanalytics.net/2014/06/custom-rankings-and-projections-for-your-league.html) possível para cada uma das projeções.

Por fim, o pacote faz a analise dos pontos obtidos possibilitando fazer [projeções de performance](https://fantasyfootballanalytics.net/2014/06/custom-rankings-and-projections-for-your-league.html) dos resultados, aggregando numa so visão a projeção de vários sites. Isaac publica semanalmente o [ranking das projeções](https://fantasyfootballanalytics.net/2018/10/gold-mining-week-7-2018.html) por posição, para os jogos da rodada, usando algumas regras de pontuação `standard` e `PPR`. 

Com todo o trabalho duro, de fazer o `data scrapping` e aplicar as regras do fantasy para calcular a pontuação já feita pelo pacote, podemos essa a informação para projetar os resultados dos times escalados nas ligas do fantasy para fazer forecast de placar dos jogos, bastando para isso obter os dados dos times, confrontos e escalações no próprio fantasy.

## Fantasy API - Getting the Team's Matchups and Rosters

Para obter os times, a escação e os confrontos da rodada de uma liga do fantasy, podemos usar a [Web API](http://api.fantasy.nfl.com/) disponibilizada. Embora tenha alguns métodos *depreciated* eles ainda funcionam e atendem ao propósito de obter as informações desejadas. Em particular precisamos apenas acessar os métodos que diz quais os jogos  [`/league/matchups`](http://api.fantasy.nfl.com/v1/docs/service?serviceName=leagueMatchups) que recebe como parametros de entrada o `token` de autenticação, o `id` da liga e a `week` da rodada devolvendo os jogos programados para aquela semana, e a API [`/league/team/matchup`](http://api.fantasy.nfl.com/v1/docs/service?serviceName=leagueTeamMatchup) que, além dos parâmetros anteriores, também recebe o `id` do time para retornar o roster escalado. 
Podemos invocar a API usando o pacote `httr` e processar o json de resposta usando o `jsonlite`.

```{r getMatchups, cache=TRUE}

# Storing the Access Token and League ID locally
# I use a yalm file to avoid hard-code them 
# or eventually version them in the GitHub :)
library(yaml)

config <- yaml.load_file("../../config/config.yml")
leagueId <- config$leagueId
authToken <- config$authToken

# invoking the API
library(httr)
library(glue) # to easily replace vars in the url

# league/matchups url
url <- "http://api.fantasy.nfl.com/v1/league/matchups?leagueId={leagueId}&week={week}&format=json&authToken={authToken}"
week <- 5

# faz a chamada na api
resp <- httr::GET(glue(url))

# Is it ok?
resp$status_code
```

Obtida a resposta da chamada, tratamos o *json* de retorno para organizar os dados e obter a escação de times.

```{r matchupHandling, warning=FALSE, message=FALSE}

library(jsonlite)
library(tidyverse)

# to convert the json in a "tabular-tibble form"
resp %>% 
  httr::content(as="text") %>%
  fromJSON(simplifyDataFrame = T) %$%  
  leagues %$%
  matchups %>%
  .[[1]] %>% 
  jsonlite::flatten() %>% 
  as.tibble() -> matchups

 matchups %>% 
   select(awayTeam.id, awayTeam.name, homeTeam.name, homeTeam.id)
```

Fazemos novas chamadas à API para obter a escalação de cada um dos times nessa rodada.

```{r getRosters, cache=TRUE, warning=FALSE, message=FALSE}

# for each teamIds in the matchup
c(matchups$awayTeam.id) %>%
  map(
    function(.teamId, .week, .leagueId, .authToken, .url) {
      # make the API call
      httr::GET(glue(.url)) %>%
        httr::content(as = "text") %>%
        fromJSON(simplifyDataFrame = T) %>% # transform response body in json
        return()
    },
    .week      = week,
    .leagueId  = leagueId,
    .authToken = authToken,
    .url       = "http://api.fantasy.nfl.com/v1/league/team/matchup?leagueId={.leagueId}&teamId={.teamId}&week={.week}&authToken={.authToken}&format=json"
  )  -> rosters.json
```


```{r checkResponse}
# this is a list with the team rosters used in this week
rosters.json[[1]]$leagues$matchup$homeTeam$name
rosters.json[[1]]$leagues$matchup$homeTeam$players[[1]] %>%
  select(id, name, position, teamAbbr) %>% 
  as.tibble()
```

Com a escalação dos times na mão (em formato *json*) processamos os dados para facilitar o tratamento. 

```{r}

# auxiliar transformation to extract team roster
extractTeam <- . %>% 
  .$players %>% 
  .[[1]] %>% 
  select( src_id=id, name, position, rosterSlot, fantasyPts ) %>%
  jsonlite::flatten() %>% 
  select(-fantasyPts.week.season, -fantasyPts.week.week ) %>% 
  rename(points = fantasyPts.week.pts) %>% 
  mutate(points = as.numeric(points) )

# extract each roster
rosters.json %>% 
  map(function(.json){
    matchup <- .json$leagues$matchup
    tibble(
      home.teamId = matchup$homeTeam$id,
      home.name   = matchup$homeTeam$name,
      home.logo   = matchup$homeTeam$logoUrl,
      home.pts    = as.numeric(matchup$homeTeam$pts),
      home.roster = list(extractTeam(matchup$homeTeam)),
      away.teamId = matchup$awayTeam$id,
      away.name   = matchup$awayTeam$name,
      away.logo   = matchup$awayTeam$logoUrl,
      away.pts    = as.numeric(matchup$awayTeam$pts),
      away.roster = list(extractTeam(matchup$awayTeam))
    ) %>% 
      return()
  }) %>% bind_rows() -> matchups.rosters

# check the matchups QBs for each team 
matchups.rosters %>% 
  mutate( away.qb = map(away.roster, function(roster) roster %>% filter(rosterSlot=="QB")),
          home.qb = map(home.roster, function(roster) roster %>% filter(rosterSlot=="QB")) ) %>%
  unnest(away.qb, home.qb, .sep=".") %>% 
  select(away.team = away.name, away.qb.name, home.qb.name, home.team=home.name )

```

Agora nós temos os jogos entre os times e suas escalações, para fazer o forecast de cada match precisamos usar o `ffanalytis` para obter a performance e pontuação de cada jogador.

